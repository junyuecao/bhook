# SoHook Web 监控 - 演示指南

## 演示准备

### 1. 环境准备（5 分钟）

```bash
# 启动 Web Dashboard
cd sohook-web
npm install
npm run dev
```

浏览器访问: http://localhost:5173

### 2. Android 应用准备

确保你的测试应用已集成 SoHook 并启动了 Web 服务器。

## 演示流程

### 场景 1: 基础功能演示（5 分钟）

#### 步骤 1: 展示初始界面
- 打开 Web Dashboard
- 介绍界面布局：
  - 左侧：连接状态配置
  - 右侧：数据展示区域

#### 步骤 2: 连接到设备
```
1. 在"连接状态"卡片中输入设备地址
   示例: http://192.168.1.100:8080
   
2. 点击"测试连接"按钮

3. 观察状态变化：
   ❌ 未连接 → ✅ 已连接
```

#### 步骤 3: 查看实时数据
```
连接成功后，自动显示：

📊 内存统计
- 总分配次数: 1,234
- 总分配大小: 128.5 KB
- 总释放次数: 1,200
- 总释放大小: 125.0 KB
- 当前泄漏次数: 34
- 当前泄漏大小: 3.5 KB
```

### 场景 2: 内存泄漏检测（10 分钟）

#### 步骤 1: 触发内存泄漏
在 Android 应用中执行会产生内存泄漏的操作：

```java
// 示例：创建内存泄漏
public void createMemoryLeak() {
    for (int i = 0; i < 10; i++) {
        // 分配但不释放
        nativeAllocateMemory(1024);
    }
}
```

#### 步骤 2: 观察统计变化
```
实时数据更新（每 2 秒）：

之前:
- 当前泄漏次数: 34
- 当前泄漏大小: 3.5 KB

之后:
- 当前泄漏次数: 44 ⬆️
- 当前泄漏大小: 13.5 KB ⬆️
```

#### 步骤 3: 查看趋势图
```
📈 内存趋势图显示：
- 蓝色线（泄漏大小）: 上升趋势
- 绿色线（泄漏次数）: 上升趋势
- 实时更新，最近 30 个数据点
```

#### 步骤 4: 查看泄漏详情
```
⚠️ 内存泄漏列表

1. 0x7b8c001000 (1024 B)
   [展开] 查看调用栈
   
2. 0x7b8c002000 (1024 B)
   [展开] 查看调用栈
   
... 共 44 个泄漏
```

#### 步骤 5: 查看调用栈（如果启用）
```
点击展开按钮，显示：

调用栈:
#0 malloc+12
#1 nativeAllocateMemory+45
#2 Java_com_example_MainActivity_nativeAllocateMemory+23
#3 ...

[复制] 按钮 - 复制完整调用栈
```

### 场景 3: 操作演示（5 分钟）

#### 操作 1: 手动刷新
```
1. 点击"刷新数据"按钮
2. 观察加载动画
3. 数据立即更新
```

#### 操作 2: 重置统计
```
1. 点击"重置统计"按钮
2. 确认对话框
3. 所有数据清零：
   - 统计归零
   - 趋势图清空
   - 泄漏列表清空
```

#### 操作 3: 配置服务器地址
```
1. 点击"连接状态"卡片的设置图标
2. 输入新地址
3. 点击"保存"
4. 自动重新连接
```

### 场景 4: 高级功能演示（5 分钟）

#### 功能 1: 调用栈复制
```
1. 展开任意泄漏记录
2. 点击"复制"按钮
3. 粘贴到文本编辑器
4. 展示完整的调用栈信息
```

#### 功能 2: 实时监控
```
1. 在 Android 应用中持续产生内存操作
2. 观察 Web Dashboard 实时更新
3. 趋势图动态变化
4. 统计数字实时增长
```

#### 功能 3: 响应式设计
```
1. 调整浏览器窗口大小
2. 观察布局自适应
3. 移动端视图演示（可选）
```

## 演示要点

### 1. 核心价值
- ✅ **实时性**: 数据每 2 秒自动刷新
- ✅ **可视化**: 直观的图表和列表
- ✅ **易用性**: 无需查看 Logcat
- ✅ **远程访问**: 任何设备浏览器访问

### 2. 技术亮点
- ✅ **现代化架构**: React + TypeScript
- ✅ **高性能**: 哈希表 O(1) 查找
- ✅ **跨平台**: Android + Web
- ✅ **RESTful API**: 标准化接口

### 3. 实用场景
- ✅ **开发调试**: 实时监控内存
- ✅ **性能测试**: 趋势分析
- ✅ **问题定位**: 调用栈追踪
- ✅ **团队协作**: 远程查看

## 常见问题演示

### Q1: 如何在不同网络环境使用？

**演示 ADB 端口转发**:
```bash
# 在终端执行
adb forward tcp:8080 tcp:8080

# 在 Web Dashboard 中使用
http://localhost:8080
```

### Q2: 如何提升性能？

**演示性能优化**:
```java
// 禁用栈回溯
SoHook.setBacktraceEnabled(false);

// 结果：性能提升 10-20 倍
```

### Q3: 数据如何导出？

**演示数据获取**:
```bash
# 通过 API 直接获取
curl http://192.168.1.100:8080/api/stats
curl http://192.168.1.100:8080/api/leaks
curl http://192.168.1.100:8080/api/leak-report
```

## 演示脚本

### 开场白（1 分钟）
```
"今天我要展示 SoHook 的 Web 监控功能。
这是一个实时的内存泄漏可视化工具，
可以帮助我们快速发现和定位内存问题。"
```

### 功能介绍（2 分钟）
```
"主要功能包括：
1. 实时内存统计 - 6 项关键指标
2. 内存趋势图 - 可视化变化趋势
3. 泄漏详情列表 - 每个泄漏的详细信息
4. 调用栈追踪 - 快速定位问题代码"
```

### 实际演示（10 分钟）
```
"让我们看一个实际的例子...
[执行演示流程]
"
```

### 总结（2 分钟）
```
"通过 Web 监控，我们可以：
- 实时查看内存状态
- 快速发现泄漏
- 准确定位问题
- 提升开发效率"
```

## 演示技巧

### 1. 准备工作
- ✅ 提前测试连接
- ✅ 准备测试数据
- ✅ 清理历史数据
- ✅ 检查网络环境

### 2. 演示节奏
- ✅ 先展示基础功能
- ✅ 再演示高级特性
- ✅ 最后回答问题
- ✅ 控制在 15-20 分钟

### 3. 互动环节
- ✅ 邀请观众提问
- ✅ 现场演示特定场景
- ✅ 分享使用经验
- ✅ 收集反馈意见

## 演示检查清单

### 开始前
- [ ] Web Dashboard 已启动
- [ ] Android 应用已运行
- [ ] Web 服务器已启动
- [ ] 网络连接正常
- [ ] 浏览器已打开

### 演示中
- [ ] 连接状态显示正常
- [ ] 数据实时更新
- [ ] 图表正常显示
- [ ] 操作响应流畅
- [ ] 无错误提示

### 结束后
- [ ] 停止 Web 服务器
- [ ] 关闭应用
- [ ] 收集反馈
- [ ] 记录问题

## 备用方案

### 如果网络连接失败
```
使用 ADB 端口转发:
adb forward tcp:8080 tcp:8080
```

### 如果数据不更新
```
1. 检查 hook 是否成功
2. 手动刷新数据
3. 查看 Logcat 日志
```

### 如果性能较慢
```
1. 禁用栈回溯
2. 增加刷新间隔
3. 减少监控的 so 库
```

## 演示素材

### 测试代码示例
```java
// 创建内存泄漏
public void demoMemoryLeak() {
    for (int i = 0; i < 10; i++) {
        byte[] leak = new byte[1024];
        nativeAllocate(leak);
        // 故意不释放
    }
}

// 正常使用
public void demoNormalUse() {
    byte[] data = new byte[1024];
    nativeAllocate(data);
    // ... 使用 ...
    nativeFree(data);
}
```

### 预期结果
```
执行 demoMemoryLeak() 后:
- 泄漏次数 +10
- 泄漏大小 +10 KB
- 趋势图上升
- 列表新增 10 条记录
```

---

**演示时长**: 15-20 分钟  
**难度级别**: 简单  
**目标观众**: 开发者、测试人员  
**准备时间**: 10 分钟
